
.. _hand_move_doc:

=========
行针控制
=========

本节为Corumi CSW系列机芯指针校准示例

背景信息
============

在CSW系列机芯中，驱动机芯使用了 ``当前值-目标值`` 的控制模型，
在文档中以 ``物理位置`` 和 ``逻辑位置`` 进行描述。

在控制模型中，驱动程序的目标就是通过驱动指针消除 ``物理位置``
和 ``逻辑位置`` 之间的差距。

``物理位置`` 即是控制器认为的指针的当前位置，但由于控制器无法
得知其现实中的位置，所以它们之间没有必然的联系。而指针校准操作
就是把 ``物理位置`` 和现实中的位置同步的过程。

``逻辑位置`` 即是控制器认为指针应该处于的目标位置。举个例子，
如果当前某根指针的 ``物理位置`` 是 ``70`` ，而 ``逻辑位置`` 是
``100`` ，则控制器将会驱动指针运行 ``30`` 步，使得 ``物理位置``
达到 ``100`` ，与 ``逻辑位置`` 相等。

为了方便指针的控制，指针系统具有数种可设置的状态，在正常走时
状态，指针的 ``逻辑位置`` 会自动的实时与时间同步。



不同型号的机芯具有不同的指针配置。每一个可以独立控制的指针系统
在控制模型中都将作为一个独立的控制对象，以齿轮箱编号描述。
访问 :ref:`device_list` 获得配置描述。

.. note::
    不同型号的机芯通过手表识别码区分。应当先获取手表识别码，
    然后根据对应识别码的机芯配置进行相应的控制。


协议描述
=============

+------+----------+------------------+------------------+
| 序号 |   内容   |        值        |                  |
+======+==========+==================+==================+
| 0    | 流控     | * fc             |                  |
+------+----------+------------------+------------------+
| 1    | 长度     | * x              |                  |
+------+----------+------------------+------------------+
| 2    | 接口索引 | * 0x02(指针控制) |                  |
+------+----------+------------------+------------------+
|      |          | * 0x01(获取)     |                  |
| 3    | 操作数   | * 0x02(设置)     |                  |
+------+----------+------------------+------------------+
| 4    | 操作对象 | * x(齿轮箱编号)  |                  |
+------+----------+------------------+------------------+
| 5    | 属性     | * 0x01(物理位置) |                  |
|      |          | * 0x02(逻辑位置) |                  |
|      |          | * 0x03(运行模式) |                  |
+------+----------+------------------+------------------+
| 6~n  | 参数     | * x(位置参数)    | * 0x00(正常)     |
|      |          |                  | * 0x01(停针)     |
|      |          |                  | * 0x02(快速正转) |
|      |          |                  | * 0x03(快速反转) |
|      |          |                  | * 0x04(手动调整) |
+------+----------+------------------+------------------+


.. note::
    每个控制对象的参数和属性(包括状态)相互独立，需要分别控制


.. warning::
    注意，运行模式具有超时机制，30秒未更新运行模式将会自动回退
    至正常模式。要维持在某种模式，需要定期发送命令更新当前模式。


指针校准
=============

因为前述原因，当指针的 ``物理位置`` 与现实中的位置不一致时，
则会导致手表的指针指示与实际时间不一致，此时便需要进行校准操作。

校准可以通过灵活使用指针控制指令完成。我们主流的校准方式有以下
两种：

  1. 直接校准方式：直接根据手表指针的现实位置设置其 ``物理位置`` 使之同步

  2. 交互校准方式：交互式调整手表指针至0点，然后设置其 ``物理位置`` 为0，
     使之同步


一般而言，对于同轴同步的机芯，使得其指针归零需要旋转的圈数很多，
所以我们会使用第一种方式。

而对于同轴异步的机芯，每根指针可以独立运行，至多旋转半圈就能够
归零，所以我们会使用第二种方式。



直接校准方式
+++++++++++++++++++

这里以识别码 ``0x03`` (同轴同步两针半)的机芯举例说明实现的过程。

主要流程如下:

1. 发送停针指令(每个对象分别定期发送，防止超时)
2. 设置指针物理位置(每个对象分别设置)
3. 发送正常模式指令

实例如下：

1. 停针指令

+ 设置大盘为停针模式：``->MCU:`` ``fc`` , ``length=5`` , ``0x02`` ,
  ``0x02`` , ``0x00`` , ``0x03`` , ``0x01``

+ 设置小盘为停针模式：``->MCU:`` ``fc`` , ``length=5`` , ``0x02`` ,
  ``0x02`` , ``0x01`` , ``0x03`` , ``0x01``

假设现在发送了停针指令之后，手表指针已经停止，此时时分针指向
的刻度为 ``3:15`` (现实观察所得)，小盘指向 ``30`` 秒的刻度。

2. 物理位置

+ 设置大盘物理位置: ``->MCU:`` ``fc`` , ``length=6`` , ``0x02`` ,
  ``0x02`` , ``0x00`` , ``0x01`` , ``0x92`` , ``0x04``

    这里，通过协议文档查询识别码 ``0x03`` 大盘物理位置为12小时
    制秒数除以 ``10`` ，
    由此计算取值为 ``(3x3600 + 15x60)/10 = 1170`` 秒。
    换算成 ``16进制`` 有 ``1170 = 0x0492`` ，按照高位在前的规则
    代入协议则得到以上的指令。

+ 同理，设置小盘物理位置: ``->MCU:`` ``fc`` , ``length=6`` , ``0x02`` ,
  ``0x02`` , ``0x01`` , ``0x01`` , ``0x00`` , ``0x1E``

3. 正常模式

+ 设置大盘为正常模式：``->MCU:`` ``fc`` , ``length=5`` , ``0x02`` ,
  ``0x02`` , ``0x00`` , ``0x03`` , ``0x00``

+ 设置小盘为正常模式：``->MCU:`` ``fc`` , ``length=5`` , ``0x02`` ,
  ``0x02`` , ``0x01`` , ``0x03`` , ``0x00``


交互校准方式
+++++++++++++++++++

这里以识别码 ``0x18`` (同轴异步两针)的机芯举例说明实现的过程。

主要流程如下:

1. 切换至手动调整模式(每个对象分别定期发送，防止超时)
2. 组合指令操作使得指针指向0点(每个对象分别设置)
3. 切换至停针模式，并设置物理位置为0
4. 切换至正常模式

实例如下：

1. 切换至手动调整模式

+ 设置分针为手动调整模式： ``->MCU:`` ``fc`` , ``length=5`` , ``0x02`` ,
  ``0x02`` , ``0x00`` , ``0x03`` , ``0x04``

+ 设置时针为手动调整模式： ``->MCU:`` ``fc`` , ``length=5`` , ``0x02`` ,
  ``0x02`` , ``0x01`` , ``0x03`` , ``0x04``

假设现在发送了手动调整指令之后，手表指针已经停止，此时时分针指向
的刻度为 ``3:15`` (现实观察所得)。

2. 组合指令操作使得指针指向0点

+ 获取分针逻辑位置: ``->MCU:`` ``fc`` , ``length=4`` , ``0x02`` ,
  ``0x01`` , ``0x00`` , ``0x02``

+ 假设得到分针逻辑位置: ``->APP:`` ``fc`` , ``length=6`` , ``0x02`` ,
  ``0x01`` , ``0x00`` , ``0x02`` , ``0x00`` , ``0x64``

    这里，通过协议文档查询识别码 ``0x18`` 分针为一圈360格，
    由此计算得到的值为 ``0x0064 = 100``

+ 设置分针逻辑位置: ``->MCU:`` ``fc`` , ``length=6`` , ``0x02`` ,
  ``0x02`` , ``0x00`` , ``0x02`` , ``0x00`` , ``0x63``

    此时，便可以以获得的逻辑位置作为基础值进行控制。比如
    这里发送逻辑位置 ``0x63 = 99`` 将会使得指针逆时针步进1步。
    再继续发送逻辑位置 ``105`` 将会使得指针顺时针步进6步。
    这里是根据用户操作控制指针运行，然后用户确认已经将指针
    调整到0点位置。

    同理，把时针也调整到0点。


3. 切换至停针模式，并设置物理位置为0

+ 设置分针停针: ``->MCU:`` ``fc`` , ``length=5`` , ``0x02`` ,
  ``0x02`` , ``0x00`` , ``0x03`` , ``0x01``

+ 设置分针物理位置: ``->MCU:`` ``fc`` , ``length=6`` , ``0x02`` ,
  ``0x02`` , ``0x00`` , ``0x01`` , ``0x00`` , ``0x00``

    时针同理。

4. 切换至正常模式

+ 设置分针为正常模式：``->MCU:`` ``fc`` , ``length=5`` , ``0x02`` ,
  ``0x02`` , ``0x00`` , ``0x03`` , ``0x00``

+ 设置时针为正常模式：``->MCU:`` ``fc`` , ``length=5`` , ``0x02`` ,
  ``0x02`` , ``0x01`` , ``0x03`` , ``0x00``

