
===========
 ClassL
===========

总览
#################

``Class L`` 为 ``Class C+`` 协议的派生分支，对协议的语义进一步进行了规范和统一。

其MTU为 ``247 bytes``

数据帧结构
====================

+------+------+
| byte |      |
+======+======+
| 0    | 流控 |
+------+------+
| 1    | 长度 |
+------+------+
| 2~n  | 载荷 |
+------+------+


.. _BYTEORDER:

字节序
====================

鉴于目前常见的蓝牙MCU均使用 ``Little-Endian`` 小端字节序，
为避免在性能受限的MCU上产生额外的性能与储存开销，协议使用MCU的原生字节序，在这里即为 ``Little-Endian`` 小端字节序。

在 ``Little-Endian`` 下
	* 一个16位的数据，如 ``0x1234 = 4660`` 传输时为 ``0x34, 0x12``
	* 一个24位的数据，如 ``0x123456 = 1193046`` 传输时为 ``0x56, 0x34, 0x12``
	* 一个32位的数据，如 ``0x12345678 = 305419896`` 传输时为 ``0x78, 0x56, 0x34, 0x12``
	* 一个Unix时间戳(32位)，如 ``0x622B096C = 1646987628 = 2022-03-11 16:33:48`` 传输时为 ``0x6C, 0x09, 0x2B, 0x62``

参考文档： `字节序 <https://zh.wikipedia.org/wiki/%E5%AD%97%E8%8A%82%E5%BA%8F>`_


.. _SIGNED_NUMBER:

有符号数
====================

在常规CPU中，有符号数以补码表示。在此为MCU原生的负整数表示方式。
在协议中，使用的有符号数均以此表示。

例如
	* 一个8位的负数, ``-1 = 0xFF`` ， ``-128 = 0x80`` , ``-127 = 0x81``
	* 一个16位的负数, ``-1 = 0xFFFF`` , ``-2 = 0xFFFE``
	* 一个32位的负数, ``-1 = 0xFFFFFFFF`` , ``-2 = 0xFFFFFFFE``

参考文档： `有符号数处理 <https://zh.wikipedia.org/wiki/%E6%9C%89%E7%AC%A6%E8%99%9F%E6%95%B8%E8%99%95%E7%90%86>`_


数据包内容
====================

数据包包含如下内容(括号中为长度)：

**流控信息** ``(1)``
	控制数据传输过程，提高传输可靠性，并完成差错控制

**载荷长度** ``(1)``
	定义当前数据包中载荷的长度

**载荷** ``(0~245)``
	数据载荷


向后兼容
====================

在两个设备建立连接时，移动端读取设备端的相关信息与协议版本。由移动端兼容设备端。

-------------

序
###################

约定
===================

.. note::
  简洁起见，描述中 ``flowcontrol（流控）`` 在以下文档中
  使用未带 ``0x`` 前缀的 ``$FC`` 缩写表示。

.. note::
  在文档描述中 ``->MCU`` 和 ``APP->`` 均表示移动端发送至MCU，
  ``MCU->`` 和 ``->APP`` 均表示MCU发送至移动端

.. note::
  在本文档中，形如 ``13`` 的无前缀数字表示十进制数

  形如 ``0x13`` 的以 ``0x`` 为前缀的数字表示十六进制数

  形如 ``0b11011011`` 的以 ``0b`` 为前缀的数字表示二进制数

.. warning::
  在本文档中， **没有** 使用 ``BCD`` 编码

  为便于理解，在某些如时间日期等的协议描述中使用了十进制来表示，
  注意，这里举例说明，如果有描述为 ``13`` 点 ``33`` 分的时间，
  其对应十六进制描述应该为 ``0x0D`` 点 ``0x21`` 分


数据结构
===================

一个完整协议帧的格式如下表所示：

+------+------+--------+
| byte | 内容 | 详情   |
+======+======+========+
| 0    | 流控 |        |
+------+------+--------+
| 1    | 长度 |        |
+------+------+--------+
| 2    |      | 索引   |
+------+      +--------+
| 3    | 载荷 | 操作数 |
+------+      +--------+
| 4~n  |      | 参数   |
+------+------+--------+


**流控**
+++++++++++++++

使用一个 ``byte`` ，为一个 ``0~255`` 的数值。

作为最近发送数据包的唯一标识。对于任何数据包的返回包都应具有相同的流控数值。

在同时乱序发送多个相似的数据包时，流控可以用来区分各个数据包的返回包。

一般建议采用递增的数值作为流控。也可以使用随机的数值作为流控。

具体处理见下方详细描述。

.. note::
	在传输中，如果是读取操作，没有收到对应的流控头的反馈，应当进行重传。

例1::

	->MCU: $FC=0x1F , $length=3 , 0xAB ,
		0x02 , 0x01 (调用 0xAB 接口, 执行 0x02 操作, 参数 0x01)
	->MCU: $FC=0x20 , $length=3 , 0xAB ,
		0x02 , 0x00 (调用 0xAB 接口, 执行 0x02 操作, 参数 0x00)
	->MCU: $FC=0x21 , $length=4 , 0x01 ,
		0x00 , 0x00 , 0xF0 (调用 0x01 接口, 执行 0x00 操作, 参数 0x00, 0xF0)

	MCU->: $FC=0x1F , $length=0 (返回流控为 0x1F 的 ACK)
	MCU->: $FC=0x21 , $length=0 (返回流控为 0x21 的 ACK)

	未收到流控 0x20 的ACK，意味着完整传输流程没有完成，需要重传。

	->MCU: $FC=0x20 , $length=3 , 0xAB ,
		0x02 , 0x00 (调用 0xAB 接口, 执行 0x02 操作, 参数 0x00)

	MCU->: $FC=0x20 , $length=0 (返回流控为 0x20 的 ACK)

.. note::
	在传输中，如果是控制或写入操作，收到最近重复的流控头，应当忽略。

例2::

	本例在 递增流控 与 缓存深度16 条件下进行描述。
	缓存深度16 表示若收到的流控位与最近收到的16个流控位中有出现相同，则视为重复。

	->MCU: $FC=0x1F , $length=3 , 0xAB ,
		0x02 , 0x01 (调用 0xAB 接口, 执行 0x02 操作, 参数 0x01)
	->MCU: $FC=0x20 , $length=3 , 0xAB ,
		0x02 , 0x00 (调用 0xAB 接口, 执行 0x02 操作, 参数 0x00)
	->MCU: $FC=0x21 , $length=4 , 0x01 ,
		0x00 , 0x00 , 0xF0 (调用 0x01 接口, 执行 0x00 操作, 参数 0x00, 0xF0)
	->MCU: $FC=0x20 , $length=3 , 0xAB ,
		0x02 , 0x01 (调用 0xAB 接口, 执行 0x02 操作, 参数 0x01)

	MCU->: $FC=0x1F , $length=0 (返回流控为 0x1F 的 ACK)
	MCU->: $FC=0x20 , $length=0 (返回流控为 0x20 的 ACK)
	MCU->: $FC=0x21 , $length=0 (返回流控为 0x21 的 ACK)
	第二次发送的流控 0x20 因为与之前重复，所以此处忽略。实际接收的为：
	( 0xAB 接口, 执行 0x02 操作, 参数 0x00 )

.. note::
	对于 **接收方** 来说，总结如下：

	在传输中，接收方如果收到最近重复的流控头，根据不同操作，建议处理如下：
	
	- 如果是控制或写入操作，应当不执行操作，只返回ACK
	- 如果是读取操作，应当按正常逻辑再次返回

	对于 **发送方** 来说，总结如下：

	在传输中，发送方如果没有收到对应流控头的反馈，根据不同情况，建议处理如下：

	- 如果是有 **副作用(side effect)** 的控制、写入或读取操作，应当使用原流控头重传完全相同的内容
	- 如果是没有 **副作用(side effect)** 的控制、写入或读取操作，除同上操作外，可以考虑使用新的流控头重传


**长度**
+++++++++++++++

表示协议帧中载荷的长度，接收方按此处长度进行解析，超出此长度定义的内容忽略。

例::

	->MCU: $FC=0x1F , $length=4 , 0xAB ,
		0x02 , 0x01 , 0x01 , 0xFF , 0x00
	此帧数据中，长度位为4，所以解析的载荷部分为:
	0xAB , 0x02 , 0x01 , 0x01
	多余的部分忽略

**索引** 、 **操作数** 与 **参数**
++++++++++++++++++++++++++++++++++++

**索引** 为协议功能的第一级分类。包含在协议内容的标题中。

**操作数** 为协议功能的第二级分类。包含在协议内容的次级标题中。

**参数** 为协议功能的详细内容。包含在功能的详细描述中。


公共语义
===================

为保证协议逻辑的一致性，对部分 **操作数** 的语义进行统一如下：

+--------+--------------+
| 操作数 | 语义         |
+========+==============+
| 0x00   | 获取(Get)    |
+--------+--------------+
| 0x01   | 设置(Set)    |
+--------+--------------+
| 0x0C   | 控制         |
+--------+--------------+
| 0x0D   | 清除(Delete) |
+--------+--------------+


-------------


内容
###################

+------+--------------+
| 序号 | 内容         |
+======+==============+
| 0    | 流控         |
+------+--------------+
| 1    | 载荷长度     |
+------+--------------+
| 2    | **接口索引** |
+------+--------------+
| 3    | **操作数**   |
+------+--------------+
| 4-n  | **参数**     |
+------+--------------+

为简洁起见，在以下协议的描述表格中将会 **省略** ``流控`` 与 ``载荷长度`` 的表示。

.. _ACK:

应答 ``ACK``
=======================

``载荷长度`` 为 ``0`` 的数据包表示 ``ACK`` ，如下所示：

+------+----------+--------------------+
| 序号 | 内容     | 值                 |
+======+==========+====================+
| 0    | 流控     | 返回帧与发送帧相同 |
+------+----------+--------------------+
| 1    | 载荷长度 | 0                  |
+------+----------+--------------------+

简洁起见，在以下内容中均以 ACK_ 直接表示，而不再重复描述其结构。


返回错误 ``0xFF``
=======================

``0xFF`` 的接口索引表示返回了一个错误。

当长度为 ``3`` 时，表示返回了一个 ``16位`` 的通用错误代码。

+------+----------------------+
| Code | 含义                 |
+======+======================+
| 303  | 能源状态拒绝(如低电) |
+------+----------------------+
| 401  | 设备未注册           |
+------+----------------------+
| 404  | 接口不存在           |
+------+----------------------+
| 405  | 无效的操作数         |
+------+----------------------+
| 406  | 无效的参数           |
+------+----------------------+
| 410  | 方法未实现或已删除   |
+------+----------------------+

例::

	->MCU: $FC , $length=3 , 0xAB ,
		0x02 , 0x01 (调用 0xAB 接口)

	MCU->: $FC , $length=3 , 0xFF ,
		0x94 , 0x01 (返回错误 0x194=404 ，表示接口 0xAB 不存在)


实时授时 ``0x01``
=======================

0x01.当前时间
++++++++++++++++++++++++++++++++++++++++++++++++

.. note::
	时间的设置与获取同时兼容 ``YYMMDDHHMMSSTT`` 与 ``Unix timestamp`` 两种格式。
	使用 ``YYMMDDHHMMSSTT`` 格式时，传输的时间为 ``UTC`` 时间。

获取
-----------------------

发送：

+------+----------+-------------------------+
| 序号 |   内容   |           值            |
+======+==========+=========================+
| 2    | 接口索引 | 0x01                    |
+------+----------+-------------------------+
| 3    | 操作数   | 0x01                    |
+------+----------+-------------------------+
| 4    | 获取     | 0x00                    |
+------+----------+-------------------------+
| 5    | 类型     | * 0x00 = YYMMDDHHMMSSTT |
|      |          | * 0x01 = Unix timestamp |
+------+----------+-------------------------+

返回 ``YYMMDDHHMMSSTT`` ：

+------+----------+---------+
| 序号 | 内容     | 值      |
+======+==========+=========+
| 2    | 接口索引 | 0x01    |
+------+----------+---------+
| 3    | 操作数   | 0x01    |
+------+----------+---------+
| 4    | 获取     | 0x00    |
+------+----------+---------+
| 5    | 类型     | 0x00    |
+------+----------+---------+
| 6    | 年       | 0~99    |
+------+----------+---------+
| 7    | 月       | 1~12    |
+------+----------+---------+
| 8    | 日       | 1~31    |
+------+----------+---------+
| 9    | 时       | 0~23    |
+------+----------+---------+
| 10   | 分       | 0~59    |
+------+----------+---------+
| 11   | 秒       | 0~59    |
+------+----------+---------+
| 12   | 时区时   | -12~+14 |
+------+----------+---------+
| 13   | 时区分   | -59~+59 |
+------+----------+---------+


.. note::

  + 返回的时间与日期均为 ``UTC时间`` ，时区使用 ``8位有符号数`` 表示，

	``MCU`` 计算时区会使用时区时和时区分相加，请保证符号正确。
  + ``-6`` , ``-30`` 表示 ``UTC-6:30`` ， ``+6`` , ``+30`` 表示 ``UTC+6:30``
  + ``-6`` , ``+30`` 会计算出 ``UTC-5:30`` 的结果，为保持代码的可读性，请勿如此使用

例::

	->MCU: $FC , $length=4 , 0x01 , 0x01 , 0x00 , 0x00

	MCU->: $FC , $length=12 , 0x01 , 0x01 , 0x00 , 0x00 ,
		0x16 (2022年), 0x0A (10月) , 0x0F (15日) ,
		$hour , $minute , $sec ,
		$timezone-hr , $timezone-min


返回 ``Unix timestamp`` ：

+------+------------+---------+
| 序号 | 内容       | 值      |
+======+============+=========+
| 2    | 接口索引   | 0x01    |
+------+------------+---------+
| 3    | 操作数     | 0x01    |
+------+------------+---------+
| 4    | 获取       | 0x00    |
+------+------------+---------+
| 5    | 类型       | 0x01    |
+------+------------+---------+
| 6~9  | Unix时间戳 | x       |
+------+------------+---------+
| 10   | 时区时     | -12~+14 |
+------+------------+---------+
| 11   | 时区分     | -59~+59 |
+------+------------+---------+

例::

	->MCU: $FC , $length=2 , 0x01 , 0x01 , 0x00 , 0x01

	MCU->: $FC , $length=8 , 0x01 , 0x01 , 0x00 , 0x01
		0x6C, 0x09, 0x2B, 0x62 (0x622B096C = 2022-03-11 16:33:48)


设置
-----------------------

发送 ``YYMMDDHHMMSSTT`` ：

+------+----------+---------+
| 序号 | 内容     | 值      |
+======+==========+=========+
| 2    | 接口索引 | 0x01    |
+------+----------+---------+
| 3    | 操作数   | 0x01    |
+------+----------+---------+
| 4    | 设置     | 0x01    |
+------+----------+---------+
| 5    | 类型     | 0x00    |
+------+----------+---------+
| 6    | 年       | 0~99    |
+------+----------+---------+
| 7    | 月       | 1~12    |
+------+----------+---------+
| 8    | 日       | 1~31    |
+------+----------+---------+
| 9    | 时       | 0~23    |
+------+----------+---------+
| 10   | 分       | 0~59    |
+------+----------+---------+
| 11   | 秒       | 0~59    |
+------+----------+---------+
| 12   | 时区时   | -12~+14 |
+------+----------+---------+
| 13   | 时区分   | -59~+59 |
+------+----------+---------+

返回：ACK_

例::

	->MCU: $FC , $length=10 , 0x01 , 0x02 ,
		$year(0-99) , $month , $day , $hour , $minute , $sec ,
		$timezone-hr , $timezone-min

	MCU->: ack


发送 ``Unix timestamp`` ：

+------+------------+---------+
| 序号 | 内容       | 值      |
+======+============+=========+
| 2    | 接口索引   | 0x01    |
+------+------------+---------+
| 3    | 操作数     | 0x01    |
+------+------------+---------+
| 4    | 设置       | 0x01    |
+------+------------+---------+
| 5    | 类型       | 0x01    |
+------+------------+---------+
| 6~9  | Unix时间戳 | x       |
+------+------------+---------+
| 10   | 时区时     | -12~+14 |
+------+------------+---------+
| 11   | 时区分     | -59~+59 |
+------+------------+---------+

例::

	->MCU: $FC , $length=8 , 0x01 , 0x01 , 0x01 , 0x01
		0x6C, 0x09, 0x2B, 0x62 (0x622B096C = 2022-03-11 16:33:48)

	MCU->: ack


指针控制 ``0x02``
====================

指针参数由 ``属性`` 和对应的 ``值`` 来确定。
属性列表如下：

+------------------------+-------------+
|      属性(1 byte)      | 值(n bytes) |
+========================+=============+
| * 物理位置[ ``0x01`` ] |             |
| * 逻辑位置[ ``0x02`` ] |             |
| * 运行模式[ ``0x03`` ] | xxxx        |
+------------------------+-------------+

其中 ``物理位置`` 和 ``逻辑位置`` 的定义及指针驱动原理见 :ref:`「行针控制」 <hand_move_doc>`,
运行模式列表如下：

+----------+------+
| 运行模式 | Hex  |
+==========+======+
| 正常     | 0x00 |
+----------+------+
| 停针     | 0x01 |
+----------+------+
| 快速正转 | 0x02 |
+----------+------+
| 快速反转 | 0x03 |
+----------+------+
| 手动调整 | 0x04 |
+----------+------+

.. note::
  未特殊说明时，物理位置与逻辑位置均采用 ``2`` 字节宽度

  访问 :ref:`「设备列表」 <device_list>` 获取不同设备的齿轮箱配置


0x01.齿轮箱控制
+++++++++++++++++++++++

获取
-----------------------

发送：

+------+----------+------+
| 序号 | 内容     | 值   |
+======+==========+======+
| 2    | 接口索引 | 0x02 |
+------+----------+------+
| 3    | 操作数   | 0x01 |
+------+----------+------+
| 4    | 获取     | 0x00 |
+------+----------+------+
| 5    | 对象     | x    |
+------+----------+------+
| 6    | 属性     | x    |
+------+----------+------+

返回：

+------+----------+------+
| 序号 |   内容   |  值  |
+======+==========+======+
| 2    | 接口索引 | 0x02 |
+------+----------+------+
| 3    | 操作数   | 0x01 |
+------+----------+------+
| 4    | 获取     | 0x00 |
+------+----------+------+
| 5    | 对象     | x    |
+------+----------+------+
| 6    | 属性     | x    |
+------+----------+------+
| 7~n  | 参数     | x    |
+------+----------+------+

例::

	->MCU: $FC , $length=4 , 0x02 , 0x01 ,
		0x01(attr1:编号01的机芯) , 0x01(attr2:物理位置)

	MCU->: $FC , $length=6 , 0x02 , 0x01 ,
		0x01(attr1:编号01的机芯) , 0x01(attr2:物理位置) ,
		0x10 , 0x27(0x2710=10000)

设置
-----------------------


发送：

+------+----------+------+
| 序号 | 内容     | 值   |
+======+==========+======+
| 2    | 接口索引 | 0x02 |
+------+----------+------+
| 3    | 操作数   | 0x01 |
+------+----------+------+
| 4    | 设置     | 0x01 |
+------+----------+------+
| 5    | 对象     | x    |
+------+----------+------+
| 6    | 属性     | x    |
+------+----------+------+
| 7~n  | 参数     | x    |
+------+----------+------+

返回：ACK_

.. note::
  当设置为非正常走时模式，设备会启动一个 ``30`` 秒的超时定时器，
  超时后自动恢复正常模式。重发设置指令可以将超时重置为 ``30`` 秒。
  当需要维持所设置状态时，建议间隔 ``10`` 秒左右重复发送此命令。

  具体超时机制时长的设置由各项目自行定义。

例::

	->MCU: $FC , $length=6 , 0x02 , 0x02 ,
		0x01(attr1:编号01的机芯) , 0x01(attr2:物理位置) ,
		0x10 , 0x27(0x2710=10000)

	MCU->: ACK


通知提醒 ``0x03``
====================

参数使用 ``byte`` 中的 ``bit`` 来分别表示提醒种类，下表仅为示例：

+---------+------+
| 参数bit | 含义 |
+=========+======+
| 7       | \\   |
+---------+------+
| 6       | \\   |
+---------+------+
| 5       | \\   |
+---------+------+
| 4       | \\   |
+---------+------+
| 3       | \\   |
+---------+------+
| 2       | 来电 |
+---------+------+
| 1       | 其他 |
+---------+------+
| 0       | \\   |
+---------+------+

具体提醒类别的定义与长度由项目文档所定义。
以下所用示例均参考上表的定义。

0x01.提醒更新
+++++++++++++++++++++++

设置
-----------------------

发送：

+------+----------+------+
| 序号 | 内容     | 值   |
+======+==========+======+
| 2    | 接口索引 | 0x03 |
+------+----------+------+
| 3    | 操作数   | 0x01 |
+------+----------+------+
| 4    | 设置     | 0x01 |
+------+----------+------+
| 5~n  | 参数bit  | x    |
+------+----------+------+

返回：ACK_


例1::

	->MCU: $FC , $length=4 ,
		0x03 , 0x01 , 0x01 ,
		0x04 (来电提醒)

	MCU->: ACK

例2::

	->MCU: $FC , $length=4 ,
		0x03 , 0x01 , 0x01 ,
		0x02 (其他提醒)

	MCU->: ACK


清除
-----------------------

发送：

+------+----------+------+
| 序号 | 内容     | 值   |
+======+==========+======+
| 2    | 接口索引 | 0x03 |
+------+----------+------+
| 3    | 操作数   | 0x01 |
+------+----------+------+
| 4    | 清除     | 0x0D |
+------+----------+------+
| 5~n  | 参数bit  | x    |
+------+----------+------+

返回：ACK_

例::

	->MCU: $FC , $length=4 ,
		0x03 , 0x01 , 0x0D ,
		0x04 (取消电话提醒)

	MCU->: ack


0x02.提醒间隔
+++++++++++++++++++++++

设置
-----------------------

发送：

+------+----------+-----------+
| 序号 |   内容   |    值     |
+======+==========+===========+
| 2    | 接口索引 | 0x03      |
+------+----------+-----------+
| 3    | 操作数   | 0x02      |
+------+----------+-----------+
| 4    | 设置     | 0x01      |
+------+----------+-----------+
| 5~6  | 提醒间隔 | 2字节秒数 |
+------+----------+-----------+

返回：ACK_

例::

	->MCU: $FC , $length=5 ,
		0x03 , 0x02 , 0x01 ,
		0x02 , 0x01 (提醒间隔设置为0x0102=258秒)

	MCU->: ack

获取
-----------------------

发送：

+------+----------+------+
| 序号 |   内容   |  值  |
+======+==========+======+
| 2    | 接口索引 | 0x03 |
+------+----------+------+
| 3    | 操作数   | 0x02 |
+------+----------+------+
| 4    | 获取     | 0x00 |
+------+----------+------+

返回：

+------+----------+-----------+
| 序号 | 内容     | 值        |
+======+==========+===========+
| 2    | 接口索引 | 0x03      |
+------+----------+-----------+
| 3    | 操作数   | 0x02      |
+------+----------+-----------+
| 4    | 获取     | 0x00      |
+------+----------+-----------+
| 5~6  | 提醒间隔 | 2字节秒数 |
+------+----------+-----------+

例2::

	->MCU: $FC , $length=3 , 0x03 , 0x03 , 0x00

	MCU->: $FC , $length=4 ,
		0x03 , 0x03 ,
		0x04 , 0x01 (表示获取到提醒间隔为0x0104=260秒)


0x03.提醒开关
+++++++++++++++++++++++

设置
-----------------------

发送：

+------+----------+------+
| 序号 |   内容   |  值  |
+======+==========+======+
| 2    | 接口索引 | 0x03 |
+------+----------+------+
| 3    | 操作数   | 0x03 |
+------+----------+------+
| 4    | 设置     | 0x01 |
+------+----------+------+
| 5    | 参数     | x    |
+------+----------+------+

返回：ACK_

例1::

	->MCU: $FC , $length=4 ,
		0x03 , 0x03 , 0x01 ,
		0x04 (来电提醒开启，且其他提醒关闭)

	MCU->: ACK

例2::

	->MCU: $FC , $length=4 ,
		0x03 , 0x03 , 0x01 ,
		0x02 (其他提醒开启，且来电提醒关闭)

	MCU->: ACK

例3::

	->MCU: $FC , $length=4 ,
		0x03 , 0x04 , 0x01 ,
		0x06 (其他与来电提醒均开启)

	MCU->: ACK

获取
-----------------------

发送：

+------+----------+------+
| 序号 |   内容   |  值  |
+======+==========+======+
| 2    | 接口索引 | 0x03 |
+------+----------+------+
| 3    | 操作数   | 0x03 |
+------+----------+------+
| 4    | 获取     | 0x00 |
+------+----------+------+

返回：

+------+----------+------+
| 序号 | 内容     | 值   |
+======+==========+======+
| 2    | 接口索引 | 0x03 |
+------+----------+------+
| 3    | 操作数   | 0x03 |
+------+----------+------+
| 4    | 获取     | 0x00 |
+------+----------+------+
| 5~n  | 参数     | x    |
+------+----------+------+

例1::

	->MCU: $FC , $length=3 , 0x03 , 0x03 , 0x00

	MCU->: $FC , $length=3 , 0x03 , 0x05 ,
		0x04 (来电提醒开启，其他提醒关闭)

例2::

	->MCU: $FC , $length=3 , 0x03 , 0x03 , 0x00

	MCU->: $FC , $length=3 , 0x03 , 0x05 ,
		0xff (所有提醒均开启)


0x11. 内容推送
+++++++++++++++++++++++

控制
-----------------------

推送提醒内容至屏幕显示

发送：

+------+----------+------+
| 序号 | 内容     | 值   |
+======+==========+======+
| 2    | 接口索引 | 0x03 |
+------+----------+------+
| 3    | 操作数   | 0x11 |
+------+----------+------+
| 4    | 控制     | 0x0C |
+------+----------+------+
| 5~n  | 参数     | x    |
+------+----------+------+

返回：ACK_

例1:
	这个示例发送了如下一段文本：
	「 ``这是一段测试文本, 用来测试显示推送内容的功能。`` 」::

		->MCU: $FC , 3(索引和操作数长度)+67(字符串长度) ,
			0x03 , 0x11 , 0x0C ,
			0xe8 , 0xbf , 0x99 , 0xe6 ,
			0x98 , 0xaf , 0xe4 , 0xb8 , 0x80 , 0xe6 ,
			0xae , 0xb5 , 0xe6 , 0xb5 , 0x8b , 0xe8 ,
			0xaf , 0x95 , 0xe6 , 0x96 , 0x87 , 0xe6 ,
			0x9c , 0xac , 0x2c , 0xe7 , 0x94 , 0xa8 ,
			0xe6 , 0x9d , 0xa5 , 0xe6 , 0xb5 , 0x8b ,
			0xe8 , 0xaf , 0x95 , 0xe6 , 0x98 , 0xbe ,
			0xe7 , 0xa4 , 0xba , 0xe6 , 0x8e , 0xa8 ,
			0xe9 , 0x80 , 0x81 , 0xe5 , 0x86 , 0x85 ,
			0xe5 , 0xae , 0xb9 , 0xe7 , 0x9a , 0x84 ,
			0xe5 , 0x8a , 0x9f , 0xe8 , 0x83 , 0xbd ,
			0xe3 , 0x80 , 0x82

		MCU->: ack


